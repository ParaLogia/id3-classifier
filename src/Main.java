import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * @author Phillip Huang (SBID#108546888)
 *
 * Data Source:
 * Lichman, M. (2013). UCI Machine Learning Repository [http://archive.ics.uci.edu/ml]. Irvine, CA: University of California, School of Information and Computer Science.
 */
public class Main {

    private static final String DEFAULT_INPUT_FILE = "wdbc.data.txt";

    /* The number of folds we will use for cross-validation. */
    private static final int FOLDS = 5;

    // Global variables for statistics below
    private static int t_pos_ct = 0;
    private static int t_neg_ct = 0;
    private static int f_pos_ct = 0;
    private static int f_neg_ct = 0;

    private static int node_ct = 0;
    private static int total_depth = 0;

    /**
     * Reads the data from a text file and returns a list of Samples.
     * Expected formatting is one sample per line, with attributes separated by commas.
     *
     * The first item is ID (which we don't use), the second is diagnosis.
     * The remaining are the attributes we test.
     */
    private static List<Sample> readData(String inputFile) throws IOException {
        return Files.lines(Paths.get(inputFile))
                .map(s -> s.split(","))
                .map(d -> {
                    Sample sample = new Sample();
                    sample.diagnosis = d[1].equals("M");
                    for (int i = 0; i < 30; i++) {
                        sample.data[i] = Double.parseDouble(d[i+2]);
                    }
                    return sample;
                })
                .collect(Collectors.toList());
    }

    /**
     * Divides the data into n folds with approx. even distribution of results in each.
     * The difference between positive and negative results in each fold varies by 2 max.
     *
     * @param data  a list of samples that need to be divided into folds
     * @param n     the number of desired folds
     * @return      an array of size n, containing the folds
     */
    private static List<Sample>[] nFoldDivide(List<Sample> data, int n) {
        // Pull out the samples with positive results/negative results
        List<Sample> positives = data.stream()
                .filter(s -> s.diagnosis)
                .collect(Collectors.toList());
        List<Sample> negatives = data.stream()
                .filter(s -> !s.diagnosis)
                .collect(Collectors.toList());

        // Randomize order and split each into equal parts for cross-validation
        Collections.shuffle(positives);
        Collections.shuffle(negatives);

        List<List<Sample>> splitPos = splitNParts(positives, n);
        List<List<Sample>> splitNeg = splitNParts(negatives, n);

        // Now we combine our split lists into our folds
        List<Sample>[] folds = new List[n];

        // We match the beginning of one split-list w/ the end of the other
        // to make sure combined list sizes don't differ by more than 1.
        // (But this lets the difference between positive/negative vary up to 2).
        for (int i = 0; i < n; i++) {
            folds[i] =
                    Stream.concat(
                            splitPos.get(i).stream(),
                            splitNeg.get(n-1-i).stream()
                    )
                            .collect(Collectors.toList());
        }

        return folds;
    }

    /**
     * Splits a list into n equal parts, if list.size() divides n. Otherwise, the
     * remainder r will be distributed among the first r sub-lists.
     *
     * @param list  the list to be split
     * @param n     the number of sublists
     * @param <T>   the type of the list
     * @return      a list containing the split sublists
     */
    private static <T> List<List<T>> splitNParts(List<T> list, int n) {
        if (n > list.size())
            throw new IllegalArgumentException("n too large for list");

        List<List<T>> rtn = new ArrayList<>();

        int q = list.size() / n;
        int r = list.size() % n;

        // The first r lists will have size q+1; the remaining will have size q
        for (int left = 0; left < list.size(); ) {
            int right = left + q;
            if (r-- > 0)
                right++;

            rtn.add(new ArrayList<>(list.subList(left, right)));

            left = right;
        }

        return rtn;
    }



    /**
     * Tests a list of samples on a decision tree, and prints out statistics
     *
     * @param tree      A decision tree generated by some other data
     * @param samples   A list of samples to test on the tree
     */
    private static void testSamples(DecisionTree tree, List<Sample> samples) {
        // Statistics: # true/false positives/negatives
        int t_pos = 0, f_pos = 0, t_neg = 0, f_neg = 0;
        for (Sample sample : samples) {
            boolean result = testSample(tree, sample);
            if (result) {
                if (sample.diagnosis) {
                    t_pos++;
//                    System.out.println(sample + "\n True Positive");
                }
                else {
                    f_pos++;
//                    System.out.println(sample + "\n False Positive");
                }
            } else {
                if (sample.diagnosis) {
                    f_neg++;
//                    System.out.println(sample + "\n False Negative");
                }
                else {
                    t_neg++;
//                    System.out.println(sample + "\n True Negative");
                }
            }
        }

        double accuracy  = (double) (t_pos + t_neg) / samples.size();
        double precision = (double) t_pos / (t_pos + f_pos);
        double recall    = (double) t_pos / (t_pos + f_neg);
        int nodes = DecisionTree.nodeCount(tree);
        int depth = DecisionTree.depth(tree);

        System.out.printf("Accuracy:  %3d/%3d = %.5f%n", (t_pos + t_neg), samples.size(), accuracy);
        System.out.printf("Precision: %3d/%3d = %.5f%n", t_pos, (t_pos + f_pos), precision);
        System.out.printf("Recall:    %3d/%3d = %.5f%n", t_pos, (t_pos + f_neg), recall);
        System.out.printf("Nodes:     %3d%n", nodes);
        System.out.printf("Depth:     %3d%n", depth);

        t_pos_ct += t_pos;
        t_neg_ct += t_neg;
        f_pos_ct += f_pos;
        f_neg_ct += f_neg;
        node_ct += nodes;
        total_depth += depth;
    }

    /**
     * Tests a given sample on a decision tree
     *
     * @param tree      The decision tree generated from any data
     * @param sample    The sample that you want to diagnose
     * @return          true if the tree predicts a positive diagnosis for the sample
     */
    private static boolean testSample(DecisionTree tree, Sample sample) {
        while (tree.result == null) {
            if (tree.leftCondition.test(sample)) {
                tree = tree.left;
            }
            else {
                tree = tree.right;
            }
        }

        return tree.result;
    }

   public static void main(String... args) throws IOException {
        List<Sample> data;

        String inputFile = null;
        Scanner in = new Scanner(System.in);

        // Read stdin for input data path
        System.out.println("Enter the path to the input file: ");
        while (true) {
            try {
                inputFile = in.next();
                if (inputFile.equalsIgnoreCase("default"))
                    inputFile = DEFAULT_INPUT_FILE;
                data = readData(inputFile);
                break;
            }
            catch (IOException ioe) {
                System.err.printf("Error reading file: %s.%nTry again: ", inputFile);
            }
        }

        System.out.println("Would you like to test on a custom data set? (y/n)");
        boolean customTestFile;
        while (true) {
            String s = in.nextLine();
            if (s.equalsIgnoreCase("y")) {
                customTestFile = true;
                break;
            }
            else if (s.equalsIgnoreCase("n")) {
                customTestFile = false;
                break;
            }
        }

        if (!customTestFile) {
            System.out.printf("%d-fold cross validation will be performed on randomly chosen folds " +
                    "(with proportional distributions). %n", FOLDS);
            System.out.println("Press enter to continue.");
            in.nextLine();

            // Split data into folds for cross-validation
            List<Sample>[] folds = nFoldDivide(data, FOLDS);

            // Now we build trees and cross-validate
            for (int i = 0; i < FOLDS; i++) {
                List<Sample> fold = folds[i];
                System.out.printf("%nFold #%d:%n", i + 1);

                // Take out the fold we're gonna use to test
                data.removeAll(fold);

                // Build tree with 4/5 folds
                DecisionTree decisionTree = ID3.buildTree(data);

                // Test our results on the fold we removed
                testSamples(decisionTree, fold);

                // Add the fold back into the data
                data.addAll(fold);
            }

            double accuracy = (double) (t_pos_ct + t_neg_ct) / (data.size());
            double precision = (double) t_pos_ct / (t_pos_ct + f_pos_ct);
            double recall = (double) t_pos_ct / (t_pos_ct + f_neg_ct);

            // Output the average from all the tests
            System.out.printf("%nAverage:%n");
            System.out.printf("Accuracy:  %3d/%3d = %.5f%n", (t_pos_ct + t_neg_ct), data.size(), accuracy);
            System.out.printf("Precision: %3d/%3d = %.5f%n", t_pos_ct, (t_pos_ct + f_pos_ct), precision);
            System.out.printf("Recall:    %3d/%3d = %.5f%n", t_pos_ct, (t_pos_ct + f_neg_ct), recall);
            System.out.printf("Nodes:     %.3f%n", (double) node_ct / (FOLDS));
            System.out.printf("Depth:     %.3f%n", (double) total_depth / (FOLDS));
        }
        else {
            System.out.println("Enter the path to your test input file: ");
            String inputFile2 = null;
            List<Sample> testData;
            while (true) {
                try {
                    inputFile2 = in.next();
                    testData = readData(inputFile2);
                    break;
                }
                catch (IOException ioe) {
                    System.err.printf("Error reading file: %s.%nTry again: ", inputFile2);
                }
            }
            DecisionTree tree = ID3.buildTree(data);
            testSamples(tree, testData);
        }
    }
}
